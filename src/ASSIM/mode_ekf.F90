!SFX_LIC Copyright 1994-2014 CNRS, Meteo-France and Universite Paul Sabatier
!SFX_LIC This is part of the SURFEX software governed by the CeCILL-C licence
!SFX_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!SFX_LIC for details. version 1.
MODULE MODE_EKF
!
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
USE PARKIND1  ,ONLY : JPRB
!
INTERFACE GET_FILE_NAME
  MODULE PROCEDURE GET_FILE_NAME
END INTERFACE
INTERFACE B_BIG_LOOP
  MODULE PROCEDURE B_BIG_LOOP
END INTERFACE
INTERFACE INVERSE_MATRIX
  MODULE PROCEDURE INVERSE_MATRIX
END INTERFACE
INTERFACE CHOLDC
  MODULE PROCEDURE CHOLDC
END INTERFACE
INTERFACE CHOLSL
  MODULE PROCEDURE CHOLSL
END INTERFACE
INTERFACE COFSWI
  MODULE PROCEDURE COFSWI
END INTERFACE
INTERFACE SET_FILEIN
  MODULE PROCEDURE SET_FILEIN
END INTERFACE
!
CONTAINS
!
SUBROUTINE GET_FILE_NAME(KYEAR,KMONTH,KDAY,KHOUR,HMFILE)
!
USE MODI_TRANS_CHAINE
!
IMPLICIT NONE
!
INTEGER, INTENT (IN) :: KYEAR, KMONTH, KDAY, KHOUR
 CHARACTER(LEN=50) :: YMONTH,YDAY,YYEAR,YHOUR
 CHARACTER(LEN=200), INTENT(INOUT) :: HMFILE
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:GET_FILE_NAME',0,ZHOOK_HANDLE)
!
 CALL TRANS_CHAINE(YMONTH,KMONTH,2)
 CALL TRANS_CHAINE(YDAY,KDAY,2)
 CALL TRANS_CHAINE(YYEAR,KYEAR,4)
 CALL TRANS_CHAINE(YHOUR,KHOUR,2)
IF (KHOUR.EQ.0 .OR. KHOUR.EQ.24 .OR. KHOUR.EQ.48) YHOUR='00'
!
HMFILE = TRIM(HMFILE)//YYEAR(3:4)
HMFILE = TRIM(HMFILE)//YMONTH
HMFILE = TRIM(HMFILE)//YDAY
HMFILE = TRIM(HMFILE)//'H'
HMFILE = TRIM(HMFILE)//YHOUR
HMFILE = TRIM(HMFILE)
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:GET_FILE_NAME',1,ZHOOK_HANDLE)
!
END SUBROUTINE GET_FILE_NAME
!
!
SUBROUTINE B_BIG_LOOP (IO, &
                       HACTION,HFILE,PTAB,PTAB_IN)
!
!
USE MODD_ISBA_OPTIONS_n, ONLY : ISBA_OPTIONS_t
!
USE MODD_ASSIM, ONLY : NVAR
!
IMPLICIT NONE
!
!
TYPE(ISBA_OPTIONS_t), INTENT(INOUT) :: IO
!
CHARACTER(LEN=4), INTENT(IN) :: HACTION
CHARACTER(LEN=*), INTENT(IN) :: HFILE
REAL, DIMENSION(:,:,:), INTENT(INOUT) :: PTAB
REAL, DIMENSION(:), INTENT(IN), OPTIONAL :: PTAB_IN
INTEGER :: JI,JJ,JK,JL,JJJ,L1,K1
INTEGER :: IKI
!RJ: missing declarations
INTEGER :: ICPT,ISTAT
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:B_BIG_LOOP',0,ZHOOK_HANDLE)
!
IF (HACTION=="READ" .OR. HACTION=="WRIT") THEN
  OPEN (UNIT=111,FILE=HFILE,FORM='UNFORMATTED',ACCESS='SEQUENTIAL',IOSTAT=ISTAT)
ELSE
  ICPT = 0
ENDIF
!
IKI = SIZE(PTAB,1)
!
DO JL = 1,NVAR   ! control variable (x at previous time step)
  DO JK = 1,NVAR
    DO JI = 1,IKI
      DO JJ = 1,IO%NPATCH   
        DO JJJ = 1,IO%NPATCH
          !
          L1 = JJ+IO%NPATCH*(JL-1)
          K1 = JJJ+IO%NPATCH*(JK-1)
          !
          IF ( HACTION=="READ" ) THEN
            READ (111) PTAB(JI,L1,K1)
          ELSEIF ( HACTION=="WRIT" ) THEN
            WRITE(111) PTAB(JI,L1,K1)
          ELSE
            ICPT = ICPT+1
            PTAB(JI,L1,K1) = PTAB_IN(ICPT)
          ENDIF
          ! 
        ENDDO
      ENDDO
    ENDDO
  ENDDO
ENDDO
!
IF (HACTION=="READ" .OR. HACTION=="WRIT") CLOSE(111)
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:B_BIG_LOOP',1,ZHOOK_HANDLE)
!
END SUBROUTINE B_BIG_LOOP

SUBROUTINE INVERSE_MATRIX(KN,PA,PP)
!--------------------------------------------------------
!
! Explicit inversed matrix after Cholesky decomposition
!
!--------------------------------------------------------
!
IMPLICIT NONE
!
INTEGER, INTENT(IN) :: KN
REAL, DIMENSION (KN,KN), INTENT(INOUT) :: PA
REAL, DIMENSION (KN),    INTENT(IN)    :: PP
REAL :: ZSUM
INTEGER :: JI, JJ, JK
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:INVERSE_MATRIX',0,ZHOOK_HANDLE)
!
DO JI = 1,KN
  PA(JI,JI)=1./PP(JI)
  DO JJ = JI+1,KN
    ZSUM = 0.
    DO JK = JI,JJ-1
      ZSUM = ZSUM - PA(JJ,JK)*PA(JK,JI)
    ENDDO
    PA(JJ,JI) = ZSUM/PP(JJ)
  ENDDO
ENDDO  
!
DO JI = 1,KN
  DO JJ = JI+1,KN
    PA(JI,JJ) = 0.0
  ENDDO
ENDDO
!
PA = MATMUL(TRANSPOSE(PA),PA)
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:INVERSE_MATRIX',1,ZHOOK_HANDLE)
!
END SUBROUTINE INVERSE_MATRIX

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE CHOLDC(KN,PA,PP)
!
USE MODI_ABOR1_SFX        
!
IMPLICIT NONE
!
INTEGER, INTENT(IN) :: KN
REAL, DIMENSION(KN,KN), INTENT(INOUT) :: PA
REAL, DIMENSION(KN), INTENT(OUT) :: PP
INTEGER :: JI
REAL :: ZSUM
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:CHOLDC',0,ZHOOK_HANDLE)
!
DO JI = 1,KN
  ZSUM = PA(JI,JI)- DOT_PRODUCT(PA(JI,1:JI-1),PA(JI,1:JI-1))
  IF ( ZSUM<=0.0 ) CALL ABOR1_SFX('MODE_EKF: ERROR IN CHOLDC')
  PP(JI) = SQRT(ZSUM) 
  PA(JI+1:KN,JI) = ( PA(JI,JI+1:KN) - MATMUL(PA(JI+1:KN,1:JI-1),PA(JI,1:JI-1)) )/PP(JI)
ENDDO
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:CHOLDC',1,ZHOOK_HANDLE)
!
END SUBROUTINE CHOLDC 

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE CHOLSL(KN,PA,PP,PB,PX)
!
IMPLICIT NONE
!
INTEGER, INTENT(IN) :: KN
REAL, DIMENSION (KN,KN), INTENT(IN) :: PA
REAL, DIMENSION (KN), INTENT(IN)    :: PP,PB
REAL, DIMENSION (KN), INTENT(INOUT) :: PX
INTEGER :: JI
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:CHOLSL',0,ZHOOK_HANDLE)
!
DO JI = 1,KN
  PX(JI) = (PB(JI) - DOT_PRODUCT(PA(JI,1:JI-1),PX(1:JI-1)))/PP(JI)
ENDDO
DO JI = KN,1,-1
  PX(JI) = (PX(JI) - DOT_PRODUCT(PA(JI+1:KN,JI),PX(JI+1:KN)))/PP(JI)
ENDDO
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:CHOLSL',1,ZHOOK_HANDLE)
!
END SUBROUTINE CHOLSL
!
SUBROUTINE COFSWI(PCLAY,PCOFSWI)
!
IMPLICIT NONE
REAL, DIMENSION(:), INTENT(IN) :: PCLAY
REAL, DIMENSION(:), INTENT(OUT) :: PCOFSWI
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:COFSWI',0,ZHOOK_HANDLE)
!
PCOFSWI(:) = 0.001 * (89.0467 * ((100.*PCLAY(:))**0.3496) - 37.1342*((100.*PCLAY(:))**0.5))
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:COFSWI',1,ZHOOK_HANDLE)
!
END SUBROUTINE COFSWI
!
!
SUBROUTINE SET_FILEIN(HFILE)
!
USE MODN_IO_OFFLINE, ONLY : CSURF_FILETYPE
!
#ifdef SFX_NC
USE MODD_IO_SURF_NC,   ONLY : CFILEIN_NC, CFILEIN_NC_SAVE
#endif
#ifdef SFX_ASC
USE MODD_IO_SURF_ASC,  ONLY : CFILEIN, CFILEIN_SAVE
#endif
#ifdef SFX_FA
USE MODD_IO_SURF_FA,   ONLY : CFILEIN_FA, CFILEIN_FA_SAVE
#endif
#ifdef SFX_LFI
USE MODD_IO_SURF_LFI,    ONLY : CFILEIN_LFI, CFILEIN_LFI_SAVE, CFILE_LFI
#endif
!
USE MODI_ABOR1_SFX
!
IMPLICIT NONE
!
 CHARACTER(LEN=*), INTENT(IN) :: HFILE
 CHARACTER(LEN=28) :: YFILEIN
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:SET_FILEIN',0,ZHOOK_HANDLE)
!
IF ( CSURF_FILETYPE == "LFI   " ) THEN
  YFILEIN = TRIM(HFILE)
#ifdef SFX_LFI
  CFILEIN_LFI      = YFILEIN 
  CFILE_LFI        = YFILEIN
  CFILEIN_LFI_SAVE = YFILEIN
#endif
ELSEIF ( CSURF_FILETYPE == "FA    " ) THEN
  YFILEIN = TRIM(HFILE)//'.fa'
#ifdef SFX_FA
  CFILEIN_FA      = YFILEIN
  CFILEIN_FA_SAVE = YFILEIN
#endif
ELSEIF ( CSURF_FILETYPE == "ASCII " ) THEN
  YFILEIN = TRIM(HFILE)//'.txt'
#ifdef SFX_ASC
  CFILEIN      = YFILEIN
  CFILEIN_SAVE = YFILEIN
#endif
ELSEIF ( CSURF_FILETYPE == "NC    " ) THEN
  YFILEIN = TRIM(HFILE)//'.nc'
#ifdef SFX_NC
  CFILEIN_NC      = YFILEIN
  CFILEIN_NC_SAVE = YFILEIN
#endif
ELSE
  CALL ABOR1_SFX(TRIM(CSURF_FILETYPE)//" is not implemented!")
ENDIF
!
IF (LHOOK) CALL DR_HOOK('MODE_EKF:SET_FILEIN',1,ZHOOK_HANDLE)
!
END SUBROUTINE SET_FILEIN
!
END MODULE MODE_EKF

